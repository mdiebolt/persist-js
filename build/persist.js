// Generated by CoffeeScript 1.6.3
(function() {
  var constructDirectoryPath, isFile, normalizePath, safeGet, safeParse, storageMode, supportsLocalStorage,
    __slice = [].slice;

  window.Persist || (window.Persist = {});

  supportsLocalStorage = function() {
    return window.localStorage != null;
  };

  safeParse = function(string) {
    var e;
    try {
      return JSON.parse(string);
    } catch (_error) {
      e = _error;
      return void 0;
    }
  };

  safeGet = function(string) {
    var e;
    try {
      return localStorage.getItem(string);
    } catch (_error) {
      e = _error;
      return void 0;
    }
  };

  constructDirectoryPath = function(directories) {
    var path;
    path = directories.join('/');
    if (!path.length) {
      path += '/';
    }
    return path;
  };

  normalizePath = function(path) {
    var length;
    if (path[0] === '/') {
      path = path.slice(1);
    }
    length = path.length;
    if (path[length - 1] === '/') {
      path = path.substr(0, length - 1);
    }
    return path;
  };

  isFile = function(string) {
    return string.indexOf('.') > -1;
  };

  storageMode = null;

  Persist.localStorage = {
    file: function(path, data) {
      var directories, directoryPath, fileName, files, item, _i, _ref;
      path = normalizePath(path);
      if (!path.length) {
        return;
      }
      _ref = path.split('/'), directories = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), fileName = _ref[_i++];
      if (!isFile(fileName)) {
        directories.push(fileName);
        fileName = '';
      }
      if (data != null) {
        directoryPath = constructDirectoryPath(directories);
        files = safeParse(safeGet(directoryPath)) || {};
        if (isFile(fileName)) {
          files[fileName] = data;
        }
        return localStorage.setItem(directoryPath, JSON.stringify(files));
      } else {
        if (isFile(fileName)) {
          directoryPath = constructDirectoryPath(directories);
          if (item = safeGet(directoryPath)) {
            return JSON.parse(item)[fileName];
          }
        } else {
          if (item = safeGet(path)) {
            return JSON.parse(item);
          }
        }
      }
    },
    remove: function(path) {
      var directories, directoryPath, fileName, item, obj, _i, _ref;
      path = normalizePath(path);
      _ref = path.split('/'), directories = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), fileName = _ref[_i++];
      if (isFile(fileName)) {
        directoryPath = constructDirectoryPath(directories);
        if (item = safeGet(directoryPath)) {
          obj = JSON.parse(item);
          delete obj[fileName];
          return localStorage.setItem(directoryPath, JSON.stringify(obj));
        }
      } else {
        if (path[path.length - 1] === '/') {
          path = path.slice(0, -1);
        }
        return localStorage.removeItem(path);
      }
    },
    toString: function() {
      var key, n, output, value, _i, _ref;
      output = '\n';
      for (n = _i = 0, _ref = localStorage.length; 0 <= _ref ? _i < _ref : _i > _ref; n = 0 <= _ref ? ++_i : --_i) {
        key = localStorage.key(n);
        value = localStorage.getItem(key);
        output += "" + key + ": " + value + "\n";
      }
      return output;
    }
  };

  if (supportsLocalStorage()) {
    storageMode = 'localStorage';
  } else {
    throw new Error("Your browser doesn't support the local storage API");
  }

  Persist.save = function(filePath, data) {
    return Persist[storageMode].file(filePath, data);
  };

  Persist.find = function(filePath) {
    return Persist[storageMode].file(filePath);
  };

  Persist["delete"] = function(filePath) {
    return Persist[storageMode].remove(filePath);
  };

  Persist.pollute = function() {
    var method, _i, _len, _ref;
    _ref = ["save", "find", "delete"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      method = _ref[_i];
      localStorage.__proto__[method] = Persist[method];
    }
    return localStorage;
  };

}).call(this);
